---
title: "エミュレータについて"
date: 2022-01-31T14:35:36+09:00
toc: true
tags:
  - development
---

遊びで作っているエミュレータについていろいろまとめておこうかなというだけの投稿。

実験で作った CPU のエミュレータです。
最初は実機でデバッグするのが辛いだろうということでアセンブラに簡易的な実行機能を
つけようといった程度のモチベーションで始めたんですが、デバッガの実装が意外に面白かったので
だんだん機能が増えてきているという感じです。

## 機能

今の所こんな感じです。

- アセンブリで書いたプログラムを実行する
- メモリの初期化ファイルに書かれた内容で内部のメモリを初期化
- 命令のアドレスにブレークポイントを置く
- 実行した命令をもとに戻す (Undo)
- 未定義動作を踏みそうになったら例外を飛ばして威嚇する

で今後無駄に実装しようと思っているのが

- 分岐命令の飛び先をラベルとかで管理できるようにする (エミュレータというよりリンカですが)
- レジスタとかメモリにウォッチポイントを置く
- 実際にメモリからプログラムを読んで実行
- 条件付きブレークポイント

という感じです。
実験で使えるという実用面からしてかなりオーバースペックになりそう。

## 使い方

### 実行

基本の使い方はこんな感じです。

1. デフォルトでも適当なプログラムが入っていますが、左側のエディタの「Program」タブを選び、アセンブリでプログラムを書きます。
2. 初期化が必要なメモリ領域があれば、同じように左側のエディタの「Memory」タブを選び、初期化ファイルの内容を書きます。
3. 上のバーの一番左にある「Load Memory and Program」をクリックします (これで一通りエミュレータの初期化が行われます)。
4. 上のバーの右の方の「Next Clock」ボタンを押すか、キーボードの右の方向キーを押すと 1 クロック分前に進みます (パイプラインは考慮していないので 1 クロック目でいきなりレジスタとかメモリが変わる)。

注意点としては今の所メモリから読んだ命令を実行しているわけではないので、自己書き換えみたいなコードは
動かないです。

見たいメモリの範囲がデフォルトと違うとかだと上のバーの Memory と書いてあるところに
開始アドレス (inclusive) と終了アドレス (exclusive) を入れて「Set Range」を押すと
メモリの表示範囲が変わります。

最初に未定義動作を踏みそうになったら例外が上がるという話をしましたが、現状で実装してあるのは
- ワードアクセスの命令でアラインされていないアドレス (奇数番地) にアクセスする

という部分です。遅延スロットに分岐命令を入れた場合も未定義らしいのでそのうち実装します。

### アセンブラ

上のバーの「Copy Assembled Program」というボタンを押すと、
アセンブリのコードをメモリの初期化ファイルに変換したものが
クリップボードに入ります。

エディタの Memory タブに入力した内容は考慮されていないので、必要であれば結合したりして使うことになります。

メモリの内容が丸ごとほしい場合は「Download Memory as C Source Code」
というボタンが使えます。
これは `mem` という `unsigned char` の配列にメモリの内容を入れるという
C のソースコードになっていて、こういう使い方を意図しています (`mem.inc` というファイルに保存するとします)。

```c
int main(void) {
    static unsigned char mem[0x10000];
#include "mem.inc"

    // mem を使っていろいろする
}
```
一応 ANSI C でもコンパイルできるはず。

#### ラベルへのジャンプ

分岐とかジャンプとかの命令は相対アドレスのかわりにラベルを引数として取ることができ、
そうすることで飛ぶ位置とのアドレスの差を意識せずにコードを書けるようになっています。

命令のアドレスにラベルを置くには `@任意の名前` と行頭に書きます。名前は C の識別子と同じ感じのルールで
つけられます (ちなみに `L1:` みたいなよくある感じの文法にしなかったのは、`:` を読むまで命令かラベルかの区別がつかず、
パースするのが若干面倒臭くなるからです)。

逆にラベルを参照するにはこれまでイミディエイトを入れていた箇所に代わりに `@名前` と入れます。

1行目と5行目の間でループする例です:
```plaintext
@loop sw r2, (r0)
addi r0, 2
mov r3, r1
sub r3, r0
bnez r3, @loop
nop
```

ラベルは定義の前に参照が来るのも合法ということになっています。これはどういうことかというと、
このコードは 1 行目から 4 行目まで飛ぶコードということになります:
```plaintext
j @label
nop
nop
@label addi r0, 1
```

また、同じ場所でずっとループさせたいみたいなときはちょっと歪な感じですが、こうなります:
```plaintext
@loop j @loop
nop
```

注意点としては遅延スロットという呪縛からは逃れられないのでちゃんと考慮して命令を入れるなり nop
を入れるなりしないといけないです。

### デバッガ

~~実行されているアドレスがハイライトされますが、普通のデバッガと違って実行済みの命令のところに
ハイライトがつきます。そのうち直します。~~  
**→普通のデバッガと同じように、次に実行される行がハイライトされるようになりました。**

#### ブレークポイント

真ん中のペインの下の方の Trace というところに実行される命令がズラズラと並んでいます。
その左側に Break というチェックボックスがありますが、それにチェックをつけることで
ブレークポイントを置けます。

ブレークポイントのアドレスがフェッチされたら実行が止まり、そこからnextしたところでブレークポイントの下の
命令が実行されるという感じです。このへんは普通のデバッガと同じです。

#### メモリやレジスタの書き換え

メモリやレジスタの中身が表示されている部分に値を入力して対応する部分の「Apply Changes」
を押すと入力した内容がエミュレータのメモリに反映されます。

10 進数で入れても 16 進数 (`0x` のプレフィックスが必要) で入れても動くはずです。

#### Continue

上の「Continue」ボタンを押すことでブレークポイントまでが高速に実行されます。
一回「Continue」を押すとボタンが「Interrupt」に変わるのですが、それを押すことで
continue しているのを止められます。ただし 10 クロックごとにしか止まらないと思うので
厳密なことはできないと思います。

#### 逆方向に実行

そのまんまです。「Reverse Next」を押すと時間が巻き戻され、実行していない状態に戻ります。

メモリやレジスタを書き換えていると書き換えたタイミングでその値も元に戻ります。
ただ、その後に順方向に実行しても自分が書き換えなかった場合の実行結果しか得られない
ので注意が必要です。「Reverse Next」は undo ですが、「Next Clock」は redo
ではないです。単純に現在の状態から次のクロックの状態まで実行するだけです。

rr とかを使うと GDB でも `rn` ができますが、これが便利だと思っていたので
実装しました。

## 内部実装について

OSSとして公開していて、[ソースコードはここに置いてあります](https://github.com/kofuk/exasm)。

アセンブラやエミュレータ本体は C++ で実装されていて、それを Emscripten で
コンパイルしてブラウザで走らせています。
C++ で実装した理由としては、最初はブラウザで動かすことをあんまり意識していなかったのと、
C か C++ か Rust か Go とかが候補で、ここから選んだからです。
C はまずめんどくさいので外すとして、で、まあこの中だったら適当なものを適当に作るのは
C++ が一番楽かなという~~短絡的な~~考えで決めました (結局テスト書いたりしているので
Rust とか Go とかの方が良かったんですが)。

一応ベタッと実装するんでなく、命令セットを定義した JSON ファイルからコード生成で
アセンブラとエミュレータを生み出すという無駄な努力によって拡張性を確保しています。
後で命令を足したくなるかもしれないので。

あんまり関係ないですが、なんとなく自動でビルドとデプロイ走ったほうが気持ちがいいという理由で
master に push したときに GitHub Actions でビルドが走り、GitHub Pages にデプロイされるようになっています。

#### 参考

- [ソースコード](https://github.com/kofuk/exasm)
